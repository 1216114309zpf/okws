Index: libaok/okprot.x
===================================================================
--- libaok/okprot.x	(revision 5589)
+++ libaok/okprot.x	(working copy)
@@ -107,6 +107,7 @@
 	ssl_ctx_t *ssl;
         okctl_timespec_t time_recv;
  	okctl_timespec_t time_sent;
+	unsigned reqno; // >1 for keepalive connections
 };
 
 struct okssl_sendcon_arg_t {
@@ -226,6 +227,9 @@
 		okctl_send_msg_res_t 
 		OKCTL_SEND_MSG (okctl_send_msg_arg_t) = 19;
 
+		okctl_sendcon_res_t
+		OKCTL_KEEPALIVE(okctl_sendcon_arg2_t) = 20;
+
 		void
 		OKCTL_KILL (oksig_t) = 99;
 
Index: libaok/ok.h
===================================================================
--- libaok/ok.h	(revision 5589)
+++ libaok/ok.h	(working copy)
@@ -646,6 +646,7 @@
 
   void set_union_cgi_mode (bool b)
   { http_parser_cgi_t::set_union_mode (b); }
+
 };
 
 //-----------------------------------------------------------------------
@@ -665,6 +666,10 @@
   virtual void process (proc_ev_t ev) = 0;
   void send_complete () {}
   void serve_complete () { delete this; }
+
+  // okclnt2_t allows use of keepalive connections, but only
+  // if this flag is toggled to true...
+  virtual bool do_keepalive () { return false; }
 private:
   void serve_T (CLOSURE);
 };
@@ -740,6 +745,8 @@
   // for accept direct connections (not via okd)
   void accept_new_con (ok_portpair_t *p);
 
+  void keepalive (ahttpcon_wrapper_t<ahttpcon> x, CLOSURE);
+
 private:
   void launch_T (CLOSURE);
 
Index: libaok/ok.T
===================================================================
--- libaok/ok.T	(revision 5589)
+++ libaok/ok.T	(working copy)
@@ -234,6 +234,22 @@
 
 //-----------------------------------------------------------------------
 
+tamed void
+oksrvc_t::keepalive (ahttpcon_wrapper_t<ahttpcon> acw)
+{
+  tvars {
+    int fd (acw.con()->takefd ());
+    okctl_sendcon_arg2_t arg;
+  }
+  
+  ctlx->sendfd (fd);
+  acw.to_xdr (&arg);
+  
+
+}
+
+//-----------------------------------------------------------------------
+
 void
 oksrvc_t::init (int argc, char *argv[])
 {
@@ -853,6 +869,7 @@
   ptr<ahttpcon> x;
   okctl_sendcon_res_t res = handle_new_con_common (arg->sin, &x);
   if (res == OK_STATUS_OK) {
+    x->set_reqno (arg->reqno);
     ahttpcon_wrapper_t<ahttpcon> acw (x, *arg);
     if (!newclnt (acw))
       res = OK_STATUS_NOMORE;
@@ -942,6 +959,11 @@
     }
   }
 
+  if (do_keepalive ()) {
+    ahttpcon_wrapper_t<ahttpcon> acw (client_con (), demux_data ());
+    get_oksrvc ()->keepalive (acw);
+  }
+
   serve_complete ();
 }
 
Index: libahttp/ahttp.C
===================================================================
--- libahttp/ahttp.C	(revision 5589)
+++ libahttp/ahttp.C	(working copy)
@@ -55,7 +55,8 @@
     destroyed_p (New refcounted<bool> (false)),
     _remote_port (0),
     _source_hash (0),
-    _source_hash_ip_only (0)
+    _source_hash_ip_only (0),
+    _reqno (0)
 {
   //
   // bookkeeping for debugging purposes;
@@ -76,7 +77,7 @@
 }
 
 int
-ahttpcon_clone::takefd ()
+ahttpcon::takefd ()
 {
   int ret = fd;
   if (fd >= 0) {
@@ -84,8 +85,15 @@
     rcbset = false;
     fdcb (fd, selread, NULL);
     fdcb (fd, selwrite, NULL);
+    fd = -1;
   }
-  fd = -1;
+  return ret;
+}
+
+int
+ahttpcon_clone::takefd ()
+{
+  int ret = ahttpcon::takefd ();
   ccb = NULL;
   _demuxed = true;
   return ret;
Index: libahttp/ahttp.h
===================================================================
--- libahttp/ahttp.h	(revision 5589)
+++ libahttp/ahttp.h	(working copy)
@@ -123,6 +123,7 @@
   //--------------------------------------------------
 
   int getfd () const { return fd; }
+  virtual int takefd ();
   inline sockaddr_in *get_sin () const { return sin; }
   inline const str & get_remote_ip () const { return remote_ip; }
   inline int get_remote_port () const { return _remote_port; }
@@ -143,6 +144,9 @@
   size_t get_bytes_sent () const { return bytes_sent; }
   size_t get_bytes_recv () const { return _bytes_recv; }
 
+  void set_reqno (u_int n) { _reqno = n; }
+  u_int get_reqno () const { return _reqno; }
+
   str select_set () const;
   str all_info () const;
   virtual str get_debug_info () const { return NULL; }
@@ -222,6 +226,9 @@
   int _remote_port;
   mutable hash_t _source_hash;
   mutable hash_t _source_hash_ip_only;
+
+protected:
+  u_int _reqno; // for Keep-Alive, this is incremented once-per
 };
 
 // for parent dispatcher, which will send fd's
Index: okd/okd.T
===================================================================
--- okd/okd.T	(revision 5589)
+++ okd/okd.T	(working copy)
@@ -520,7 +520,7 @@
 
 tamed void
 okd_t::newserv2 (int port, int nfd, sockaddr_in *sin, bool proxied,
-		 const ssl_ctx_t *ssl)
+		 const ssl_ctx_t *ssl, u_int reqno)
 {
   tvars {
     ref<ahttpcon_clone> x (ahttpcon_clone::alloc (nfd, sin));
@@ -531,6 +531,8 @@
     int status;
   }
 
+  x->set_reqno (reqno);
+
   reqid ++;
 
   // debug messaging
@@ -1089,6 +1091,24 @@
  
 //-----------------------------------------------------------------------
 
+void
+okd_t::handle_keepalive (int fd, svccb *sbp)
+{
+  RPC::okctl_program_1::okctl_keepalive_srv_t<svccb> srv (sbp);
+  const okctl_sendcon_arg2_t *arg (srv.getarg ());
+  okctl_sendcon_res_t res (OK_STATUS_OK);
+  if (fd >= 0) {
+    sockaddr_in *sin = (sockaddr_in *)xmalloc (sizeof (sockaddr_in));
+    memcpy (sin, arg->sin.base (), sizeof (sockaddr_in));
+    newserv2 (arg->port, fd, sin, false, arg->ssl, arg->reqno + 1);
+  } else {
+    res = OK_STATUS_ERR;
+  }
+  srv.reply (res);
+}
+
+//-----------------------------------------------------------------------
+
 tamed void
 okd_t::custom1_in (svccb *sbp)
 {
Index: okd/okd.h
===================================================================
--- okd/okd.h	(revision 5589)
+++ okd/okd.h	(working copy)
@@ -300,7 +300,7 @@
 	       evv_t ev, CLOSURE);
   void newserv (int fd);
   void newserv2 (int port, int nfd, sockaddr_in *sin, bool prx, 
-		 const ssl_ctx_t *ssl, CLOSURE);
+		 const ssl_ctx_t *ssl, u_int reqno = 0, CLOSURE);
   void shutdown (int sig) { shutdown_T (sig); }
   void shutdown_T (int sig, CLOSURE);
   void awaken (const oksvc_proc_t &p, evb_t ev, CLOSURE);
@@ -335,6 +335,7 @@
   void turnlog (svccb *sbp, CLOSURE);
   void strip_privileges ();
   void send_msg (svccb *sbp, CLOSURE);
+  void handle_keepalive (int fd, svccb *sbp);
 
   bool in_shutdown () const { return sdflag; }
   void set_signals ();
Index: okd/child.T
===================================================================
--- okd/child.T	(revision 5589)
+++ okd/child.T	(working copy)
@@ -564,6 +564,15 @@
   case OKCTL_GET_STATS:
     _myokd->okctl_get_stats (sbp);
     break;
+  case OKCTL_KEEPALIVE:
+    {
+      int fd = ctlx->recvfd();
+      if (fd < 0) {
+	CH_ERROR ("Got invalid FD in keepalive passback");
+      } 
+      _myokd->handle_keepalive (fd, sbp);
+    }
+    break;
   case OKCTL_REENABLE_ACCEPT:
     handle_reenable_accept (sbp);
     break;
