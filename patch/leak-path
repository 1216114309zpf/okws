Index: libaok/okprot.x
===================================================================
--- libaok/okprot.x	(revision 4034)
+++ libaok/okprot.x	(working copy)
@@ -64,7 +64,9 @@
   OK_STATUS_NOMORE = 5,
   OK_STATUS_BADFD = 6,
   OK_STATUS_DUP = 7,
-  OK_STATUS_BADWAKEUP = 8
+  OK_STATUS_BADWAKEUP = 8,
+  OK_STATUS_UNAVAIL = 9,
+  OK_STATUS_UNKNOWN_OPTION = 10
 };
 
 union ok_custom_res_union_t switch (ok_xstatus_typ_t status) {
@@ -120,6 +122,18 @@
   OKLOG_SSL = 6
 };
 
+enum ok_leak_checker_cmd_t {
+     OK_LEAK_CHECKER_ENABLE = 1,
+     OK_LEAK_CHECKER_DISABLE = 2,
+     OK_LEAK_CHECKER_RESET = 3,
+     OK_LEAK_CHECKER_REPORT = 4
+};
+
+struct okmgr_leak_checker_arg_t {
+  ok_prog_t prog;
+  ok_leak_checker_cmd_t cmd;
+};
+
 struct oklog_notice_t {
   string notice<>;
 };
@@ -239,6 +253,9 @@
 		oksvc_stats_t
 		OKCTL_GET_STATS_FROM_SVC(void) = 15;
 
+		ok_xstatus_typ_t
+		OKCTL_LEAK_CHECKER(ok_leak_checker_cmd_t) = 16;
+
 		void
 		OKCTL_KILL (oksig_t) = 99;
 
@@ -294,6 +311,9 @@
 
 		ok_xstatus_t
 		OKMGR_REPUB2 (xpub_fnset_t) = 6;
+
+		ok_xstatus_t
+		OKMGR_LEAK_CHECKER(okmgr_leak_checker_arg_t) = 7;
 	} = 1;
 } = 11278;
 
@@ -343,4 +363,4 @@
 	} = 1;
 } = 11281;
 
-};
+}; /* namespace RPC */
Index: libaok/ok.h
===================================================================
--- libaok/ok.h	(revision 4034)
+++ libaok/ok.h	(working copy)
@@ -745,6 +745,7 @@
 
   void handle_new_con (svccb *sbp);
   void handle_get_stats (svccb *v);
+  void handle_leak_checker (svccb *v);
   bool newclnt (ahttpcon_wrapper_t<ahttpcon> acw);
   void update (svccb *sbp, CLOSURE);
   void kill (svccb *v);
Index: libaok/ok.T
===================================================================
--- libaok/ok.T	(revision 4039)
+++ libaok/ok.T	(working copy)
@@ -332,6 +332,42 @@
 //-----------------------------------------------------------------------
 
 void
+oksrvc_t::handle_leak_checker (svccb *sbp)
+{
+  RPC::okctl_program_1::okctl_leak_checker_srv_t<svccb> srv (sbp);
+  ok_xstatus_typ_t status;
+
+#ifdef SIMPLE_LEAK_CHECKER
+  ok_leak_checker_cmd_t cmd (*srv.getarg ());
+  status = OK_XSTATUS_OK;
+  switch (cmd) {
+  case OK_LEAK_CHECKER_ENABLE:
+    simple_leak_checker_enable ();
+    break;
+  case OK_LEAK_CHECKER_DISABLE:
+    simple_leak_checker_disable ();
+    break;
+  case OK_LEAK_CHECKER_REPORT:
+    simple_leak_checker_report ();
+    break;
+  case OK_LEAK_CHECKER_CLEAR:
+    simple_leak_checker_clear ();
+    break;
+  default:
+    status = OK_STATUS_UNKNOWN_OPTION;
+    break;
+  }
+
+#else /* !SIMPLE_LEAK_CHECKER */
+  status = OK_STATUS_UNAVAIL;
+#endif /* SIMPLE_LEAK_CHECKER */
+
+  srv.reply (status);
+}
+
+//-----------------------------------------------------------------------
+
+void
 oksrvc_t::ctldispatch (svccb *v)
 {
   if (!v) {
@@ -362,6 +398,9 @@
   case OKCTL_GET_STATS_FROM_SVC:
     handle_get_stats (v);
     break;
+  case OKCTL_LEAK_CHECKER:
+    handle_leak_checker (v);
+    break;
   default:
     v->reject (PROC_UNAVAIL);
     break;
Index: okd/okd.T
===================================================================
--- okd/okd.T	(revision 4035)
+++ okd/okd.T	(working copy)
@@ -1307,7 +1307,27 @@
 
 //-----------------------------------------------------------------------
 
+tamed void
+okd_t::toggle_leak_checker (svccb *sbp)
+{
+  tvars {
+    RPC::okmgr_program_1::okmgr_leak_checker_srv_t<svccb> srv (sbp);
+    const okmgr_leak_checker_arg_t *arg (srv.getarg ());
+    ok_xstatus_typ_t status;
+    okch_t *ch;
+  }
+  
+  if ((ch = servtab[arg->prog])) {
+    twait { ch->toggle_leak_checker (arg->cmd, mkevent (status)); }
+  } else {
+    status = OK_STATUS_NOSUCHCHILD;
+  }
+  srv.reply (status);
+}
 
+//-----------------------------------------------------------------------
+
+
 int
 main (int argc, char *argv[])
 {
Index: okd/mgrsrv.C
===================================================================
--- okd/mgrsrv.C	(revision 4034)
+++ okd/mgrsrv.C	(working copy)
@@ -61,6 +61,9 @@
   case OKMGR_CUSTOM_2:
     myokd->custom2_in (sbp);
     break;
+  case OKMGR_LEAK_CHECKER:
+    myokd->toggle_leak_checker (sbp);
+    break;
   default:
     sbp->reject (PROC_UNAVAIL);
     break;
Index: okd/okmgr.T
===================================================================
--- okd/okmgr.T	(revision 4034)
+++ okd/okmgr.T	(working copy)
@@ -31,7 +31,7 @@
 static void
 usage ()
 {
-  warnx << "usage: okmgr [-l | -p | -t | -1] [-a?] "
+  warnx << "usage: okmgr [-l | -p | -t | -1] [-a?] [-s <socket>]"
 	<< "<file1> <file2> ...\n";
   exit (1);
 }
Index: okd/okd.h
===================================================================
--- okd/okd.h	(revision 4034)
+++ okd/okd.h	(working copy)
@@ -132,6 +132,9 @@
   void set_state (okc_state_t s) { state = s; }
 
   void stats_collect (okd_stats_t *s, evv_t ev, CLOSURE);
+
+  void toggle_leak_checker (ok_leak_checker_cmd_t cmd, 
+			    event<ok_xstatus_typ_t>::ref ev, CLOSURE);
   
   okd_t *myokd;
   int pid;
@@ -273,6 +276,7 @@
   void relaunch (const ok_progs_t &x, okrescb cb);
   void custom1_in (svccb *sbp);
   void custom2_in (svccb *sbp);
+  void toggle_leak_checker (svccb *sbp, CLOSURE);
   void okctl_get_stats (svccb *sbp);
   void turnlog (okrescb cb);
 
Index: okd/child.T
===================================================================
--- okd/child.T	(revision 4034)
+++ okd/child.T	(working copy)
@@ -572,3 +572,32 @@
 }
 
 //-----------------------------------------------------------------------
+
+tamed void
+okch_t::toggle_leak_checker (ok_leak_checker_cmd_t cmd, 
+			     event<ok_xstatus_typ_t>::ref ev)
+{
+  tvars {
+    clnt_stat err;
+    ok_xstatus_typ_t status;
+  }
+  
+  if (!clnt) {
+    LDCH_ERROR("cannot connect to client for leak_checker toggle");
+    status = OK_STATUS_DEADCHILD;
+  } else {
+   
+    twait {
+      RPC::okctl_program_1::
+	okctl_leak_checker (clnt, cmd, &status, mkevent (err));
+    }
+
+    if (err) {
+      LDCH_ERROR ("RPC failure in leak_checker: " << err);
+      status = OK_STATUS_ERR;
+    }
+  }
+  ev->trigger (status);
+}
+
+//-----------------------------------------------------------------------
