/* $Id: genheader.C 2349 2006-12-03 19:12:46Z max $ */

/*
 *
 * Copyright (C) 1998 David Mazieres (dm@uun.org)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA
 *
 */

#include "rpcc.h"

static void
pmshl (str id)
{
  aout << "bool xml_" << id << " (XML_RPC_obj_t *, void *);\n";
}

static void
dumpstruct (const rpc_sym *s)
{
  const rpc_struct *rs = s->sstruct.addr ();
  aout << "bool rpc_traverse (" XML_OBJ "*t, " << rs->id << " &obj);\n" ;
  pmshl(rs->id);
}

static void
dumpunion (const rpc_sym *s)
{
  const rpc_union *rs = s->sunion.addr ();
  aout << "bool rpc_traverse (" XML_OBJ " *t, " << rs->id << " &obj);\n";
  pmshl (rs->id);
}

static void
dumpenum (const rpc_sym *s)
{
  const rpc_enum *rs = s->senum.addr ();
  aout << "bool rpc_traverse (" XML_OBJ " *t, " << rs->id << "&obj);\n";
  pmshl (rs->id);
}

static void
dumptypedef (const rpc_sym *s) {}

static void
dumpprog (const rpc_sym *s)
{
  const rpc_program *rs = s->sprogram.addr ();
  for (const rpc_vers *rv = rs->vers.base (); rv < rs->vers.lim (); rv++) {
    aout << "extern const xml_rpc_program xml_" << rpcprog (rs, rv) << ";\n";
  }
  aout << "\n";
}

static void
dumpsym (const rpc_sym *s)
{
  switch (s->type) {
  case rpc_sym::CONST:
    aout << "enum { " << s->sconst->id
	 << " = " << s->sconst->val << " };\n";
    break;
  case rpc_sym::STRUCT:
    dumpstruct (s);
    break;
  case rpc_sym::UNION:
    dumpunion (s);
    break;
  case rpc_sym::ENUM:
    dumpenum (s);
    break;
  case rpc_sym::TYPEDEF:
    dumptypedef (s);
    break;
  case rpc_sym::PROGRAM:
    dumpprog (s);
    break;
  default:
    break;
  }
}

static str
makeguard (str fname)
{
  strbuf guard;
  const char *p;

  if ((p = strrchr (fname, '/')))
    p++;
  else p = fname;

  guard << "__RPCC_";
  while (char c = *p++) {
    if (isalnum (c))
      c = toupper (c);
    else
      c = '_';
    guard << c;
  }
  guard << "_INCLUDED__";

  return guard;
}

void
genheader (str fname, str xdr_headername)
{
  str guard = makeguard (fname);

  aout << "// -*-c++-*-\n"
       << "/* This file was automatically generated by rpcc. */\n\n"
       << "#ifndef " << guard << "\n"
       << "#define " << guard << " 1\n\n"
       << "#include \"xdrmisc.h\"\n"
       << "#include \"okxmlxlate.h\"\n"
       << "#include \"" << stripfname (xdr_headername) << "\"\n";


  int last = rpc_sym::LITERAL;
  for (const rpc_sym *s = symlist.base (); s < symlist.lim (); s++) {
    if (last != s->type
	|| last == rpc_sym::PROGRAM
	|| last == rpc_sym::TYPEDEF
	|| last == rpc_sym::STRUCT
	|| last == rpc_sym::UNION
	|| last == rpc_sym::ENUM)
      aout << "\n";
    last = s->type;
    dumpsym (s);
  }

  aout << "extern xml_rpc_file " << stripfname (fname, false) 
       << "_rpc_file;\n\n";

  aout << "#endif /* !" << guard << " */\n";
}
